package chapter09.item67

class Item67 {
    /*
    (맹목적인 어리석음을 포함해) 그 어떤 핑계보다 효율성이라는 이름 아래 행해진 컴퓨팅 죄악이 더 많다. - 윌리엄 울프
    자그마한 효율성은 모두 잊자. 섣부른 최적화가 만악의 근원이다. - 도널드 크누스
    최적화 할 때는 다음의 두 규칙을 따르라. 첫 번째, 하지마라. 두 번째, (전문가 한정) 아직 하지 마라, 다시 말해 완전히 명백하고 최적화되지 않은 해법을 찾을 때까지 하지마라. - M.A 잭슨

    - 빠른 프로그램보다는 좋은 프로그램이 좋다.
        성능때문에 견고한 구조를 희생하지 말아야 한다. 좋은 프로그램이지만 원하는 성능이 나오지 않는다면 그 아키텍처 자체가 최적화 할 수 있는 길을 안내해줄 것이다.
        다만, 프로그램 완성 시까지 성능을 무시하라는 말은 아니다.
        애초에 설계 단계에서 성능을 반드시 염두에 두어야 한다. 아키텍처의 결함이 성능을 제한하는 상황이라면 전체를 다시 작성하지 않고는 해결이 불가능하기 때문이다.

    - 성능을 제한하는 설계를 피하라.
        완성 후 변경하기 어려운 설계 요소는 컴포넌트끼리, 혹은 외부 시스템과의 소통 방식이다.
        대표적인 예로는 API, 네트워크 프로토콜, 영구 저장용 데이터 포맷 등이 있다.
        이런 설계 요소들은 완성 후에 변경이 어렵거나 불가능할 수 있으며, 동시에 시스템 성능을 심각하게 제한할 수 있다.

    - API를 설계할 때 성능에 주는 영향을 고려하라.
        public 메소드에서 내부 데이터를 변경할 수 있게 만들면 불필요한 방어적 복사를 유발한다.
        또한 컴포지션으로 해결할 수 있는 public 클래스를 상속으로 처리한다면 영원히 상위 클래스에 종속되고 성능까지 물려받는다.
        또한 인터페이스도 있는데 굳이 구현 타입을 사용하면 특정 구현체에 종속되게 하여, 나중에 더 빠른 구현체가 나오더라도 이용하지 못하게 된다.

    - 성능을 위해 API를 왜곡하는건 매우 안좋은 생각이다.
        API를 왜곡하도록 만든 그 성능 문제는 언젠가 사라질 수 있지만, 왜곡된 API와 이를 지원하는 데 따르는 고통은 영원하다.
        신중히 설계하고, 깨끗하고 명확한 구조를 갖춘 프로그램을 완성한 다음에야 최적화를 고려해볼 차례가 된다. 물론 성능을 만족하지 못했을 때만.

    - 각각의 최적화 시도 전후로 성능을 측정하라.
        프로그램에서 시간을 잡아먹는 부분을 추측하기 어려워 시도한 최적화 기법이 성능을 눈에 띄게 높이지 못하는 경우가 많다.

    - 프로파일링 도구는 최적화 노력을 어디에 집중해야할지 알려준다.
        이런 도구는 개별 메서드의 소비 시간과 호출 횟수 같은 런타임 정보를 제공한다. 집중해야 할 곳은 물론 알고리즘을 변경해야 한다는 사실을 알려주기도 한다.
    */
}